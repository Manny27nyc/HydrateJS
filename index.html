<!doctype html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

	<title>nanodeath/HydrateJS @ GitHub</title>
	
	<style type="text/css">
		body {
			margin-top: 1.0em;
  			background-color: #BFEFFF;
			font-family: "Helvetica,Arial,FreeSans";
			color: #000000;
		}
		#container {
			margin: 0 auto;
			min-width: 700px;
			max-width: 900px;
		}
		h1 { font-size: 3.8em; color: #c53302; margin-bottom: 3px; }
		h1 .small { font-size: 0.4em; }
		h1 a { text-decoration: none }
		h2 { font-size: 1.5em; color: #c53302; }
    	h3 { text-align: center; color: #c53302; }
    	a { color: #c53302; }
    	.description { font-size: 1.2em; margin-bottom: 30px; margin-top: 30px; font-style: italic;}
    	.download { float: right; }
		pre { background: #000; color: #fff; padding: 15px;}
    	hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    	.footer { text-align:center; padding-top:30px; font-style: italic; }
    td {
      vertical-align: top;
    }
    html .syntaxhighlighter {
      overflow: visible !important;
    }
	</style>
	<link href="css/shCore.css" rel="stylesheet" type="text/css" />
	<link href="css/shThemeDefault.css" rel="stylesheet" type="text/css" />
</head>

<body>
  <a href="http://github.com/nanodeath/HydrateJS"><img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub" /></a>

  <div id="container">

    <div class="download">
      <a href="http://github.com/nanodeath/HydrateJS/zipball/master">
        <img border="0" width="90" src="http://github.com/images/modules/download/zip.png"></a>
      <a href="http://github.com/nanodeath/HydrateJS/tarball/master">
        <img border="0" width="90" src="http://github.com/images/modules/download/tar.png"></a>
    </div>

    <h1><a href="http://github.com/nanodeath/HydrateJS">HydrateJS</a>
      <span class="small">by <a href="http://github.com/nanodeath">nanodeath</a></span></h1>

    <div class="description">
      Make javascript object serialization a snap!  Have you found JSON.stringify and JSON.parse insufficient?  HydrateJS may be what you're looking for.
Note: designed mainly for browsers, but may have a place with server-side code as well.  Untested though.
    </div>

    <p>Native JSON serialization (via JSON.stringify) is convenient, but has a couple critical pitfalls:
    <ol>
      <li>If your Javascript object is actually an instance of something other than a hash ({}), this information is lost when serializing -- so a method that may have existed pre-serialization on an object won't exist post-deserialization.</li>
      <li>Another problem is circular references -- they simply don't work (JSON will throw an exception).</li>
      <li>Lastly, object references -- i.e. two elements in an array that point to the exact same object -- aren't deserialized as one might expect.</li>
    </ol>
    HydrateJS aims to fix all those.
<h2>Dependencies</h2>
<p>Only json2.js, but this is bundled with HydrateJS and automatically required into the page as needed.</p>
<h2>Install</h2>
<p>
<ul>
<li>Option 1: Download pre-compiled JS from <a href="http://blog.maxaller.name/hydrate/gen/Hydrate.js">here</a>.</li>
<li>Option 2: HydrateJS is written in CoffeeScript, a new spiffy language that compiles down to JavaScript.  You can get started here: <a href="http://www.coffeescript.com/" target="_blank">http://www.coffeescript.com/</a>. (you'll need to install Node and npm if you haven't already, but that should take no more than 5 minutes).  Then run ./compile.sh.</li>
</ul>
</p>
<h2>Limitations</h2>
Due to the nature of JavaScript, there are some limitations in order to make serialization work.
<ul>
  <li>
    Can't use anonymous functions as constructors.
    Reason: to identify the constructor used to build an object, the framework uses the constructor's #name property.  Anonymous functions have a blank name.
    <table>
      <tr><th>Bad</th><th>Good</th></tr>
      <tr>
        <td>
          <script type="syntaxhighlighter" class="brush: js"><![CDATA[
          var Person = function(name){
            ...
          };
          ]]></script>
        </td>
        <td>
          <script type="syntaxhighlighter" class="brush: js"><![CDATA[
          function Person(name){
            ...
          };
          ]]></script>
        </td>
      </tr>
      <tr>
        <td>
          <script type="syntaxhighlighter" class="brush: js"><![CDATA[
          var Person = {
            Janitor: function(){ ... },
            CEO: function(){ ... }
          };
          ]]></script>
        </td>
        <td>
          <script type="syntaxhighlighter" class="brush: js"><![CDATA[
          function Janitor(name){
            ...
          };
          function CEO(name){
            ...
          };
          // Alternatively, if you REALLY want namespacing:
          var Person = {
            Janitor: function(){ ... },
            CEO: function(){ ... }
          };
          for(var f in Person){ 
            Person[f].constructor_name = f;
          }
          var resolver = new Hydrate.ContextResolver(Person);
          var hydrate = new Hydrate(resolver);
          ...
          ]]></script>
        </td>
      </tr>
    </table>
  </li>
  <li>
    Can't attach functions to instances.  This is part of the general "can't serialize functions" rule, and even if you could, I'm pretty sure it'd cause more problems than solve.  I know this doesn't work well with certain Javascript patterns out there, but since the Person constructor would never get called on the deserialized object, there's no way we could attach #getName to the deserialized instance.  We can't call the constructor on the instance either because a) we don't know what args to pass in, and b) it may have other undesirable side effects.
    <table>
      <tr><th>Bad</th><th>Good</th></tr>
      <tr>
        <td>
          <script type="syntaxhighlighter" class="brush: js"><![CDATA[
            function Person(name){
              this.getName = function(){
                return name;
              };
            }
          ]]></script>
        </td>
        <td>
          <script type="syntaxhighlighter" class="brush: js"><![CDATA[
            function Person(name){
              this._name = name;
            }
            Person.prototype.getName = function(){
              return this._name;
            };
          ]]></script>
        </td>
      </tr>
    </table>
  </li>
  <li>
    Can't write to the "constructor" property of an object.  In order to deserialize an object, we must know what its constructor was (and more importantly, the constructor's prototype object).  The only way to do this is by taking the constructor property from the to-be-serialized object.
    <table>
      <tr><th>Bad</th><th>Good</th></tr>
      <tr>
        <td>
          <script type="syntaxhighlighter" class="brush: js"><![CDATA[
            function Person(){}
            var bob = new Person();
            bob.constructor = "something";
          ]]></script>
        </td>
        <td>
          <script type="syntaxhighlighter" class="brush: js"><![CDATA[
            function Person(){}
            var bob = new Person();
            bob.not_the_constructor = "something";
          ]]></script>
        </td>
      </tr>
      <tr>
        <td>
          <script type="syntaxhighlighter" class="brush: js"><![CDATA[
            // If, for some reason, you thought you had
            // a good reason to do this, you *could*,
            // though I wouldn't recommend it.
            function Person(){}
            function Dog(){}
            var bob = new Person();
            bob.constructor = Dog;
            // or even bob.constructor = {name: "Dog"};
            // serialize
            var hydrate = new Hydrate();
            var bob_string = hydrate.stringify(bob);
            // deserialize
            var bob_the_dog = hydrate.parse(bob_string);
            // now Bob is a Dog object...weird.
          ]]></script>
        </td>
        <td></td>
      </tr>
    </table>
  </li>
</ul>
<h2>License</h2>
<p>MIT license -- do what you want.</p>
<h2>Authors</h2>
<p>Max Aller (nanodeath@gmail.com)</p>
<h2>Contact</h2>
<p>Max Aller (nanodeath@gmail.com)</p>


    <h2>Download</h2>
    <p>
      You can download this project in either
      <a href="http://github.com/nanodeath/HydrateJS/zipball/master">zip</a> or
      <a href="http://github.com/nanodeath/HydrateJS/tarball/master">tar</a> formats.
    </p>
    <p>You can also clone the project with <a href="http://git-scm.com">Git</a>
      by running:
      <pre>$ git clone git://github.com/nanodeath/HydrateJS</pre>
    </p>

    <div class="footer">
      get the source code on GitHub : <a href="http://github.com/nanodeath/HydrateJS">nanodeath/HydrateJS</a>
    </div>

  </div>

  <script src="js/shCore.js"></script>
  <script src="js/shBrushJScript.js"></script>
  <script>
    SyntaxHighlighter.defaults.toolbar = false;
    SyntaxHighlighter.all();
  </script>
</body>
</html>
